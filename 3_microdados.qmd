---
title: "3. Microdados"
from: markdown+emoji
code-annotations: hover
---

# 3.1 Dados disponíveis no {censobr}


O **{censobr}** é um pacote de R para acessar os dados e documentação dos censos demográficos do Brasil [@pereira2023censobr]. O pacote disponibiliza microdados da amostra de todas as edições do censo demográfico desde 1970. A Tabela 1 apresenta abaixo todas as bases de dados do censo que você consegue acessar com o **{censobr}**.

**Tabela 1. Funções de dados disponíveis no {censobr}**

```{=html}
<!DOCTYPE html>
<html lang="en">
<head>
  <!-- <meta charset="UTF-8"> -->
  
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        table {
            width: 100%;
            border-collapse: collapse;
        }
        table, th, td {
            border: 1px solid black; /* Thicker border for better visibility */
        }
        th, td {
            padding: 10px;
            text-align: center;
        }
    </style>
</head>
<body>

<table border="1" cellpadding="5" cellspacing="0">
  <thead>
    <tr>
      <th rowspan="2">Função</th>
      <th rowspan="2">Origem</th>
      <th rowspan="2">Unidade</th>
      <th rowspan="2">Definição</th>
      <th colspan="6">Disponibilidade</th>
    </tr>
    <tr>
      <th>1960</th>
      <th>70</th>
      <th>80</th>
      <th>91</th>
      <th>2000</th>
      <th>10</th>
      <th>22</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>read_population()</td>
      <td>Amostra</td>
      <td>Microdado</td>
      <td>Lê os microdados de pessoas.</td>
      <td><i>em breve</i></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
      <td><i>em breve</i></td>
    </tr>
    <tr>
      <td>read_households()</td>
      <td>Amostra</td>
      <td>Microdado</td>
      <td>Lê os microdados de domicílios.</td>
      <td><i>em breve</i></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td><i>em breve</i></td>
    </tr>
    <tr>
      <td>read_families()</td>
      <td>Amostra</td>
      <td>Microdado</td>
      <td>Lê os microdados de famílias do censo de 2000.</td>
      <td></td>
      <td></td>
      <td></td>
      <td>X</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>read_emigration()</td>
      <td>Amostra</td>
      <td>Microdado</td>
      <td>Lê os microdados de emigração.</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>X</td>
      <td></td>
      <td><i>em breve</i></td>
    </tr>
    <tr>
      <td>read_mortality()</td>
      <td>Amostra</td>
      <td>Microdado</td>
      <td>Lê os microdados de mortalidade.</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>X</td>
      <td><i>em breve</i></td>
    </tr>
    <tr>
      <td>read_tracts()</td>
      <td>Universo</td>
      <td>Setor Censitário</td>
      <td>Lê os dados do Universo agregados por setores censitários.</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>X</td>
      <td>em breve</td>
    </tr>
  </tbody>
</table>

</body>
</html>
```

Todas as funções de leitura de microdados possuem a mesma estrutra (sintaxe), o que permite o usuário baixar os dados de maneira fácil e intuitiva com um único comando. As funções possuem os seguintes parâmetros:

```{r, eval = FALSE}
read_households(
  year,          # ano de referência
  columns,       # seleciona colunas que devem ser lidas
  add_labels,    # adiciona os 'labels' das variáveis categóricas
  as_data_frame, # retorna resultado como um `Arrow DataSet` ou `data.frame`
  showProgress,  # mostra contagem de download
  cache          # salva arquivo em cache para rapida leitura posteriormente
  )
```


::: {.callout-important appearance="default"}
## Cache local dos dados

A primeira vez que o usuário executa uma função, o **{censobr}** fará o download dos dados e os armazenará localmente numa pasta do pacote. Dessa forma, os dados precisam ser baixados apenas uma vez. Mais informações na seção *Cache de Dados* abaixo.

:::


# 3.2 Trabalhando com dados maior do que a RAM

![](images/arrow_plus_dplyr.png){width=350 fig-align="center"}

É muito comum que os microdados do censo brasileiro sejam grandes demais para serem carregados na memória RAM do usuário. Para resolver esse problema, o **{censobr}** foi construído sobre a plataforma [Arrow](https://arrow.apache.org/docs/r/) e arquivos em formato `.parquet`, o que permite que o usuário trabalhe de maneira eficiente até mesmo com bases de dados muito grandes utilizando funções já bem conhecidas do pacote [{dplyr}](https://arrow.apache.org/docs/r/articles/arrow.html#analyzing-arrow-data-with-dplyr).


Vamos então partir para exemplos na prática, e começar carregando as bibliotecas que usamos.


```{r, message = FALSE}
#| label: load-libraries
# carrega bibliotecas
library(censobr)
library(arrow)
library(dplyr)
library(ggplot2)
```


# 3.3 Dados de população

Neste exemplo, nós vamos criar um gráfico da pirâmica populacional do Brasil no ano de 2010. O primeiro passo é usar a função `read_population()` para carregar os microdados de população.

O comportamento padrão das as funções do **{censobr}** é retornar *todas* as variáveis das bases de dados. No entanto, como vamos fazer uma análise simples, o mais eficiente é passarmos um vetor com os nomes das colunas que vamos utilizar (neste caso, as variáveis de peso amostral, sexo e idade).

```{r, message=FALSE}
#| label: read-population-data
pop <- read_population(
  year = 2010,
  columns = c('V0010', 'V0601', 'V6036'),  # <1>
  add_labels = 'pt',                       # <2>
  showProgress = TRUE
  )

class(pop)

```
1. Aumentando eficiência ao ler apenas as colunas que vamos usar
2. Adicionando os 'labels' em Português das variáveis categóricas.


Por padrão, a saída da função é um `"arrow_dplyr_query"` ou `"ArrowObject"`. Isso permite que você trabalhe com os dados do censo de maneira super rápida e eficiente, mesmo que a tabela de dados seja grande demais para a memória do seu computador. Note que se você passar o parâmetro `as_data_frame = TRUE`, a função carregará os dados como um `data.frame` na memória RAM. ***Atenção***: isso pode fazer com que a sessão do R trave em ambientes com restrições computacionais.

Esse output em arrow pode ser analisado como de maneira similar a como se analisaria um `data.frame` utilizando-se funções do pacote {dplyr}. Uma diferença, no entanto, é que as operações somente são executadas quando o usuário roda a função `dplyr::collect()` 

Aqui, por exemplo, nós visualizamos as primeiras linhas da tabela de dados:

```{r}
#| label: head-population-data
head(pop) |> collect()

```

O próximo passo é criar um variável categória com grupos de idade a cada 5 anos.

```{r}
#| label: create-age-variable
pop <- pop |>
  mutate(
    age_group = dplyr::case_when(
      V6036 <= 04              ~ "00-05",
      V6036 >= 05 & V6036 < 10 ~ "05-10",
      V6036 >= 10 & V6036 < 15 ~ "10-15",
      V6036 >= 15 & V6036 < 20 ~ "15-20",
      V6036 >= 20 & V6036 < 25 ~ "20-25",
      V6036 >= 25 & V6036 < 30 ~ "25-30",
      V6036 >= 30 & V6036 < 35 ~ "30-35",
      V6036 >= 35 & V6036 < 40 ~ "35-40",
      V6036 >= 40 & V6036 < 45 ~ "40-45",
      V6036 >= 45 & V6036 < 50 ~ "45-50",
      V6036 >= 50 & V6036 < 55 ~ "50-55",
      V6036 >= 55 & V6036 < 60 ~ "55-60",
      V6036 >= 60 & V6036 < 65 ~ "60-65",
      V6036 >= 65 & V6036 < 70 ~ "65-70",
      V6036 >= 70              ~ "75+"
      ))

head(pop) |> collect()
```

E em seguida, nós só precisamos somar o número de homens e mulheres em cada grupo de idade. Para isso, nós somamos os valores da variável de peso amostral `V0010` em cada grupo. Repare que ao chamarmos a função `collect()`, o código é executado e retorna um `data.frame`.

```{r}
#| label: summarize-pop-table
piramide_df <- pop |>
               group_by(V0601, age_group) |>
               summarise(pop_count = sum(V0010)) |>
               collect()

head(piramide_df)
```
Pronto, no último passo é só fazer o gráfico de pirâmide populacional utilizando o pacote {ggplot2}.

```{r}
#| label: pop-pyramid-ggplot
#| code-fold: true
#| fig-cap: "Pirâmide demográfica, Brasil, 2010"

# remove grupo com idade missing `NA`
piramide_df <- filter(piramide_df, !is.na(age_group))

# transforma a contagem de mulheres para valores negativos
piramide_df <- piramide_df |>
  mutate(pop_count = if_else(V0601 == "Masculino", pop_count, -pop_count))

# figura
ggplot(data = piramide_df,
       aes(x = pop_count / 1000,
           y = age_group,
           fill = V0601)) +
  geom_col() +
  scale_fill_discrete(name="", type=c("#ffcb69","#437297")) +
  scale_x_continuous(labels = function(x){scales::comma(abs(x))},
                     breaks = c(-8000, -4000,0,4000, 8000),
                     name = "População (em milhares)") +
  theme_classic() +
  theme(
    legend.position = "top",
    axis.title.y=element_blank(),
    panel.grid.major.x = element_line(color = "grey90")
  )

```


# 3.4 Dados de domicílios

### Saneamento:

Neste exemplo, nós vamos usar os dados de domicílios do censo de 2010 para calcular qual proporção de domicílios conectados à rede de esgoto nos municípios de cada região do Brasil. O primeiro passo é baixar os dados utilizando a função `read_households()`.

```{r, message=FALSE}
#| label: read-household-data
dom <- read_households(year = 2010, 
                      showProgress = FALSE)

```

Agora vamos (a) agrupar as observações por região e município, (b) obter o número de domicílios conectados à rede de esgoto, (c) obter o número total de domicílios, (d) calcular a proporção de domicílios conectados e (e) coletar os resultados.

```{r warning = FALSE}
#| label: compute-sewage-connection
esg <- dom |> 
        compute() |>
        group_by(name_region, code_muni) |>                  # (a)
        summarize(rede = sum(V0010[which(V0207=='1')]),      # (b)
                  total = sum(V0010)) |>                     # (c)
        mutate(cobertura = rede / total) |>                  # (d)
        collect()                                            # (e)

head(esg)
```
Uma rápida análise da dispersão dos valores com o *box-plot* abaixo já revela um dos retratos da desigualdade regional brasileira. Menos de 50% dos domicílios estão conectados à rede de esgoto em todos municípios da região Norte e quase metade dos municípios da região Nordeste. No próximo bloco, nós vamos visualizar essas diferenças se distribuiem espacialmente.

```{r}
#| label: plot-sewage-regions
ggplot(esg) +
  geom_boxplot(aes(x=reorder(name_region, -cobertura), y=cobertura, 
                   weight  = rede, color=name_region), 
               show.legend = F, outlier.alpha = 0.1) +
  scale_y_continuous(labels = scales::percent) +
  labs(x="Região", y="Quantidade de domicílios\nconectados à rede de esgoto") +
  theme_classic()

```


# 3.5 Análise espacial com {geobr}

O **{geobr}** é um pacote para baixar dados espaciais oficiais do Brasil [@pereira2019geobr]. Ele inclui uma ampla variedade de dados geoespaciais disponíveis em várias escalas geográficas e para diversos anos, como municípios, regiões metropolitanas, biomas, estabelecimentos de saúde, etc (veja a [lista completa no site do pacote](https://ipeagit.github.io/geobr/)).

::: {.callout-information appearance="default"}
## Integração entre {censobr} e {geobr}

teste


<div style="display: flex; justify-content: space-around;">
  <img src="/images/censobr_logo.png" style="max-width: 20%; height: auto;">
  <img src="/images/geobr_logo_y.png" style="max-width: 20%; height: auto;">
</div>



test markown

<div style="display: flex; justify-content: space-around;">
  ![Image 1](images/censobr_logo.png){style="max-width: 25%;"}
  ![Image 2](images/geobr_logo_y.png){style="max-width: 25%;"}
</div>

teste markdown2

<div style="display: flex; justify-content: space-around;">
  ![Image 1](images/censobr_logo.png){width=250 fig-align="center"}
  ![Image 2](images/geobr_logo_y.png){width=250 fig-align="center"}
</div>


Todos os dados do **{censobr}** são enriquecidos com colunas de geografia, seguindo os padrões de nomenclatura do pacote **{geobr}** para facilitar a manipulação e a integração de dados espaciais dos censos demográficos do Brasil. As colunas adicionadas são: `c('code_muni', 'code_state', 'abbrev_state', 'name_state', 'code_region', 'name_region', 'code_weighting', 'code_tract')`.

:::

Para criarmos uma mapa com a distribuição espacial da cobertura de esgotamento no Brasil, nós vamos primeiro usar o pacote **{geobr}** para baixar as geometrias dos municípios brasileiros no anos de 2010. Vamos também sobrepor os limites das grandes regiões do país para dar um pouco mais de contexto à figura.

```{r warning = FALSE, message=FALSE}
#| label: geobr-read-municipality
library(geobr)

regioes_df <- read_region(year = 2010)
muni_sf <- read_municipality(year = 2010)

head(muni_sf)
```

Agora nós só precisamos unir os dados espaciais com nossas estimativas utilizando a variável chave `code_muni` e mapear os resultados.

```{r warning = FALSE}
#| label: merge-geobr-censobr-plot-map
# merge data
esg_sf <- left_join(muni_sf, esg, by = 'code_muni')

# plot map
ggplot() +
  geom_sf(data = esg_sf, aes(fill = cobertura), color=NA) +
  geom_sf(data = regioes_df, color = 'gray20', fill=NA) +
  labs(title = "Quantidade de domicílios conectados à rede de esgoto") +
  scale_fill_distiller(palette = "Greens", direction = 1, 
                       name='Proporção de\ndomicílios', 
                       labels = scales::percent) +
  theme_void() +
  theme(legend.position = 'bottom')

```

### Distribuição espacial do valor do aluguel:

No exemplo anterio, nós agregamos os microdados do censo no nível de municípios. Neste próximo exemlo, faremos uma análise espacial no nível de áreas de ponderação. Aqui nós vamos visualizar como o valor do aluguel varia espacialmente na região metropolitana de São Paulo. 

Primeiro, vamos baixar os municípios da região metropolitana de São Paulo com o **{geobr}**.

```{r warning = FALSE, message=FALSE}
#| label: geobr-read-metro-sp
metro_muni <- geobr::read_metro_area(year = 2010) |> 
              filter(name_metro == "RM São Paulo")
```

Também precisamos dos polígonos das áreas de ponderação. Com o código abaixo, baixamos todas as áreas de ponderação do estado de São Paulo e, em seguida, mantemos apenas aquelas na região metropolitana de São Paulo.

```{r warning = FALSE}
#| label: geobr-read-areas-area
wt_areas <- geobr::read_weighting_area(code_weighting = "SP",
                                       year = 2010,
                                       simplified = FALSE)

wt_areas <- filter(wt_areas, code_muni %in% metro_muni$code_muni)
head(wt_areas)
```

Agora voltamos para a base de dados de domicílios do censo de 2010. Com essa base, nós precisamos calcular o valor médio do aluguel gasto em cada área de ponderação. Note que para isso nós usamos a média do aluguel `V2011` ponderada pela variável do peso do domicílio `V0010`. Para encontrar esses valores,  o código abaixo (a) filtra apenas as observações nos nossos municípios de interesse, (b) computa temporariamente o resultado, (c) agrupa as observações por área de ponderação, (d) calcula o valor médio do aluguel e (e) coleta os resultados.

```{r warning = FALSE}
#| label: censobr-calcula-alugel-areapond
rent <- dom |>
        filter(code_muni %in% metro_muni$code_muni) |>                     # (a)
        compute() |>                                                       # (b)
        group_by(code_weighting) |>                                        # (c)
        summarize(avgrent=weighted.mean(x=V2011, w=V0010, na.rm=TRUE)) |>  # (d)
        collect()                                                          # (e)

head(rent)
```

Por fim, podemos unir os dados espaciais com nossas estimativas de aluguel pela variável chave `code_weighting`, e mapear os resultados.

```{r warning = FALSE}
#| label: plot-alugel-areapond
rent_sf <- left_join(wt_areas, rent, by = 'code_weighting')

ggplot() +
  geom_sf(data = rent_sf, aes(fill = avgrent), color=NA) +
  geom_sf(data = metro_muni, color='gray', fill=NA) +
  labs(title = "Valor médio do aluguel por área de ponderação",
       subtitle = "Região Metropolitana de São Paulo, 2010") +
  scale_fill_distiller(palette = "Purples", direction = 1, 
                       name='Valores\nem R$',
                       labels = scales::number_format(big.mark = ".")) +
  theme_void()

```



# 3.5 Data cache

Na primeira vez que o usuário executa uma função, o **{censobr}** fará o download do arquivo e o armazenará localmente. Dessa forma, os dados só precisam ser baixados uma vez. Quando o parâmetro `cache` está configurado como `TRUE` (Padrão), a função lerá os dados em cache, o que é muito mais rápido.

Os usuários podem gerenciar os conjuntos de dados em cache usando a função `censobr_cache()`. Por exemplo, os usuários podem:

Listar arquivos em cache:

```{r warning=FALSE}
censobr_cache(list_files = TRUE)
```

Deletar um arquivo específico:
```{r warning=FALSE}
censobr_cache(delete_file = "2010_emigration")

```

Deletar todos arquivos do cache:
```{r warning=FALSE}
censobr_cache(delete_file = "all")

```

Por padrão, os arquivos do **{censobr}** são salvos no diretório 'User'. No entanto, os usuários podem executar a função `set_censobr_cache_dir()` para definir um diretório de cache personalizado. Note que essa definição personalizada precisa ser definida a cada nova sessão do R.

```{r, eval=FALSE, warning=FALSE}
tempf <- tempdir()

set_censobr_cache_dir(path = tempf)

```

















